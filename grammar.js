// any sequence alternating `zeb` and `ra`, like the black and white of a zebra
// in theory, `zeb` and `ra` are equivalent, in practice, the order matters
// for instance, in a math group, the `zeb` must be `expr` and `ra` must be `ws`
// the reason why it behaves this way is unclear, although I suspect the `ws` in
// math operators to mislead the parser when a `ws` is found after an `expr`
function zebra(zeb, ra) {
  return seq(optional(ra), repeat(seq(zeb, ra)), optional(zeb));
}
function joined(elem, sep) {
  return seq(repeat(seq(elem, sep)), elem);
}
function ws($) {
  return repeat(choice($._space_expr, $.comment));
}
function content($) {
  return zebra(
    seq(optional($._redent), choice($.break, $._new_line)),
    choice(
      $._indented,
      $.heading,
      $.item,
      $.term,
      repeat1($._markup)
    )
  );
}
function inside($) {
  return zebra(
    seq(optional($._redent), choice($.break, $._new_line)),
    choice(
      seq($.heading, $._new_line),
      $._indented,
      $.item,
      $.term,
      prec.left(repeat1($._markup))
    )
  );
}
module.exports = grammar({
  name: 'typst',
  extras: $ => [],
  externals: $ => [
    $._indent,
    $._dedent,
    $._redent,
    $._content_token,
    $._strong_token,
    $._emph_token,
    $._termination,
  ],
  conflicts: $ => [
    [$._math_add, $._math_sub, $._math_mul, $._math_div, $._math_attach_sup, $._math_attach_sub],
    [$._math_group, $._math_item_call],
    [$._math_group, $._math_call],
    [$.math],
    [$._math_group],
    [$.item],
    [$._code],
    [$.let],
    [$.import],
    [$.elude],
    [$.return],
    [$.return_inline],
    [$.tagged, $._expr],
    [$.tagged, $._expr, $._pattern],
    [$._expr, $._pattern],
    [$._code, $.field],
    [$.or, $.not, $.and, $.cmp, $.in, $.add, $.sub, $.mul, $.div],
    [$.or, $.and, $.cmp, $.in, $.add, $.sub, $.mul, $.div],
  ],
  rules: {
    source_file: $ => content($),

    _token_dlim: $ => /[ ]*(\n|;)/,
    _token_dlim_blck: $ => token(prec(1, /[ ]*(\n|;)/)),
    break: $ => /\n([ \t]*\n)+/,
    escape: $ => /\\[^\nu]|\\u\{[0-9a-fA-F]*\}/,
    comment: $ => choice(
      seq('//', /[^\n]*\n?/),
      seq('/*', repeat(choice(/[^\*\/]|\*[^\/]|\/[^\/\*]/, $.comment)), '*/'),
    ),
    url: $ => prec.right(seq(/http(s?):\/\//, $.text)),

    _space_expr: $ => /[ \n\t]+/,
    _new_line: $ => /\n/,
    _space: $ => /[ \t]+/,
    _token_eq: $ => token(prec(1, /=/)),

    _anti_else: $ => /[ \n\t]*else[^ \t\{\[]/,
    _anti_markup: $ => /[\p{L}0-9][_\*\"][\p{L}0-9]/,
    _anti_item: $ => prec(1, /(-|\+|[0-9]+\.)[^ \t\n]/),
    _anti_head: $ => /=+[^ \t\n=]/,

    _token_item: $ => prec(1, /-|\+|[0-9]+\./),
    _token_term: $ => prec(1, /\/[ \t]+/),
    _token_head: $ => /=+/,
    _token_else: $ => /[ \n\t]*else/,
    _token_dot: $ => /\./,
    line: $ => /\\/,
    quote: $ => choice('"', '\''),

    _char_any: $ => /./,

    _markup: $ => choice(
      $._code,
      $.text,
      $.strong,
      $.emph,
      $._space,
      $.comment,
      $.raw_blck,
      $.raw_span,
      $.math,
      $.url,
      $.label,
      $.ref,
      $.symbol,
      $.quote,
    ),
    _markup_inside: $ => choice(
      $._code,
      $.text,
      $.strong,
      $.emph,
      $._space,
      $._new_line,
      $.comment,
      $.raw_blck,
      $.raw_span,
      $.math,
      $.url,
      $.label,
      $.ref,
      $.symbol,
      $.quote,
    ),

    text: $ => prec.right(repeat1(choice(
      $._anti_else,
      $._anti_markup,
      $._anti_item,
      $._anti_head,
      $._token_dot,
      $._char_any,
      $.escape,
      $.line,
    ))),

    _indented: $ => seq($._indent, content($), $._dedent),
    item: $ => prec.right(1, seq(
      optional($._space),
      $._token_item,
      repeat($._markup),
      optional($._indented)
    )),
    term: $ => prec.right(1, seq(
      optional($._space),
      $._token_term,
      field('term', repeat($._markup)),
      ':',
      repeat($._markup),
      optional($._indented)
    )),

    heading: $ => seq($._token_head, repeat($._markup)),
    strong: $ => prec.left(seq($._strong_token, inside($), $._termination)),
    emph: $ => prec.left(seq($._emph_token, inside($), $._termination)),
    raw_blck: $ => seq('```', field('lang', optional($.ident)), alias(/[^`a-zA-Z](``[^`]|`[^`]|[^`])*/, $.blob), '```'),
    raw_span: $ => seq('`', alias(/[^`]*/, $.blob), '`'),
    symbol: $ => choice('--', '---', '-?', '~', '...'),

    math: $ => seq('$', zebra($._math_expr, ws($)), '$'),
    _math_code: $ => prec(8, seq('#', choice($._item, $._stmt), optional($._token_dlim))),
    _math_expr: $ => choice(
      $._math_code,
      $.line,
      alias($._math_group, $.group),
      alias($._math_letter, $.variable),
      alias($._math_number, $.number),
      alias($._math_symbol, $.symbol),
      alias($._math_mul, $.mul),
      alias($._math_div, $.div),
      alias($._math_add, $.add),
      alias($._math_sub, $.sub),
      alias($._math_attach_sup, $.attach),
      alias($._math_attach_sub, $.attach),
      alias($._math_item_call, $.item_call),
      alias($._math_call, $.call),
      $._math_item,
    ),
    _math_group: $ => prec(-1, seq(choice('(', '[', '{'), zebra($._math_expr, ws($)), optional(choice(')', ']', '}')))),
    _math_item: $ => choice(alias($._math_ident, $.ident), alias($._math_field, $.field)),
    // FIXME: exclude `_` from math ident
    _math_ident: $ => /[\p{XID_Start}][\p{XID_Continue}]+/,
    _math_letter: $ => choice(/[\p{XID_Start}]/, $.escape, $.string),
    _math_number: $ => /[0-9]+/,
    _math_mul: $ => prec.left(3, seq($._math_expr, ws($), '*', ws($), $._math_expr)),
    _math_div: $ => prec.left(3, seq($._math_expr, ws($), '/', ws($), $._math_expr)),
    _math_add: $ => prec.left(2, seq($._math_expr, ws($), '+', ws($), $._math_expr)),
    _math_sub: $ => prec.left(2, seq($._math_expr, ws($), '-', ws($), $._math_expr)),
    // TODO: support for dual attach (both sub and sup on a single syntax node)
    _math_attach_sup: $ => prec.right(4,
      seq($._math_expr, ws($), '^', ws($), field('sup', $._math_expr))
    ),
    _math_attach_sub: $ => prec.right(4,
      seq($._math_expr, ws($), '_', ws($), field('sub', $._math_expr))
    ),
    _math_field: $ => prec.left(7, seq($._math_item, '.', alias($._math_ident, $.ident))),
    _math_item_call: $ => prec(6, seq($._math_item, '(', zebra(ws($), $._math_expr), ')')),
    _math_call: $ => prec(5, seq(choice(alias($._math_letter, $.variable), $._math_item), $._math_group)),
    _math_symbol: $ => choice(
      token(prec(-1 , '+')),
      token(prec(-1 , '-')),
      token(prec(-1 , '*')),
      token(prec(-1 , '/')),
      token(prec(-1 , '=')),
      token(prec(-1 , ':=')),
      token(prec(-1 , '=>')),
      token(prec(-1 , '!=')),
      token(prec(-1 , '!')),
      token(prec(-1 , '<=')),
      token(prec(-1 , '>=')),
      token(prec(-1 , '<')),
      token(prec(-1 , '>')),
      token(prec(-1 , ')')),
      token(prec(-1 , ']')),
      token(prec(-1 , '}')),
      token(prec(-1 , '&')),
      token(prec(-1 , '|')),
      token(prec(-1 , '...')),
    ),

    _code: $ => seq('#', choice($._item, $._stmt), optional($._token_dlim)),

    _item: $ => prec(1, choice(
      $.auto,
      $.none,
      $.flow,
      $.builtin,
      $.ident,
      $.label,
      $.bool,
      $.number,
      $.string,
      $.branch,
      $.field,
      $.block,
      $.group,
      $.call,
      $.content,
    )),

    _stmt: $ => choice(
      $.let,
      $.set,
      $.import,
      $.include,
      $.for,
      $.while,
      $.show,
      alias($.return_inline, $.return),
    ),

    _expr: $ => choice(
      $.auto,
      $.none,
      $.flow,
      $.builtin,
      $.ident,
      $.label,
      $.bool,
      $.number,
      $.string,
      $.branch,
      $.field,
      $.block,
      $.group,
      $.elude,
      $.assign,
      $.lambda,
      $.not,
      $.or,
      $.and,
      $.cmp,
      $.in,
      $.add,
      $.sub,
      $.mul,
      $.div,
      $.sign,
      $.call,
      $.content,
      $.let,
      $.set,
      $.import,
      $.include,
      $.for,
      $.while,
      $.show,
      $.return,
    ),

    _pattern: $ => choice(
      $.ident,
      $.group,
    ),

    ident: $ => /[\p{XID_Start}_][\p{XID_Continue}\-]*/,
    unit: $ => choice('cm', 'mm', 'em', '%', 'fr', 'pt', 'in', 'deg', 'rad'),
    bool: $ => choice('true', 'false'),
    number: $ => prec.right(seq(/[0-9]+(\.[0-9]+)?/, optional($.unit))),
    string: $ => seq('"', repeat(choice(/[^\"\\]/, $.escape)), '"'),
    // elude, assign and lambda have strange behavior if no optional space place at the end
    // see test 139, 140 and 142
    elude:  $ =>      prec(2, seq('..', optional(seq(ws($), $._expr)), ws($))),
    assign: $ => prec.right(3, seq(field('pattern', $._pattern), ws($), choice('=', '+=', '-=', '*=', '/='), ws($), field('value', $._expr), ws($))),
    lambda: $ => prec.right(4, seq(field('pattern', $._pattern), ws($), '=>', ws($), field('value', $._expr), ws($))),
    or:     $ => prec.left(5, seq($._expr, ws($), 'or', ws($), $._expr)),
    not:    $ => prec.left(6, seq('not', ws($), $._expr)),
    and:    $ => prec.left(6, seq($._expr, ws($), 'and', ws($), $._expr)),
    cmp:    $ => prec.left(7, seq($._expr, ws($), choice('<', '>', '<=', '>=', '==', '!='), ws($), $._expr)),
    // FIXME: `not in` with comments and spaces
    in:     $ => prec.left(8, seq($._expr, ws($), choice('not in', 'in'), ws($), $._expr)), 
    add:    $ => prec.left(9, seq($._expr, ws($), '+', ws($), $._expr)),
    sub:    $ => prec.left(9, seq($._expr, ws($), '-', ws($), $._expr)),
    mul:    $ => prec.left(10, seq($._expr, ws($), '*', ws($), $._expr)),
    div:    $ => prec.left(10, seq($._expr, ws($), '/', ws($), $._expr)),
    sign:   $ =>      prec(11, seq(choice('+', '-'), ws($), $._expr)),

    call:   $ => seq(field('item', $._item), choice($.content, $.group)),
    field:  $ => seq($._item, $._token_dot, field('field', $.ident)),
    tagged: $ => seq(field('field', choice($.ident, $.string)), ws($), ':', ws($), $._expr),
    label: $ => seq('<', /[\p{XID_Start}\-_][\p{XID_Continue}\-_]*/, '>'),
    ref: $ => seq('@', /[\p{XID_Start}\-_][\p{XID_Continue}\-_]*/),
    content: $ => seq($._content_token, content($), $._termination),
    group: $ => seq(
      '(',
      repeat(seq(
        ws($),
        choice($.tagged, $._expr),
        ws($),
        ','
      )),
      ws($),
      optional(seq(choice($.tagged, $._expr), ws($))),
      ')'
    ),
    block: $ => seq(
      '{',
      repeat(seq(
        prec.left(optional(choice($._expr, $.comment))),
        // this token as the precedence over regular new lines inside expression
        // that way, a new line is a separator between expressions
        $._token_dlim_blck,
        optional($._space_expr),
      )),
      optional(choice($._expr, $.comment)),
      '}'
    ),
    branch: $ => prec.left(2, seq(
      'if',
      ws($), 
      field('test', $._expr), 
      ws($),
      choice($.block, $.content),
      optional(seq(alias($._token_else, 'else'),
        ws($),
        choice($.block, $.content, $.branch)
      )),
    )),
    let: $ => prec(0, seq(
      'let',
      ws($),
      field('pattern', choice($._pattern, $.call)),
      optional(seq(
        ws($),
        $._token_eq,
        ws($),
        field('value', $._expr)
      )),
      ws($),
    )),
    set: $ => prec(0, seq(
      'set',
      ws($),
      $.call,
    )),
    import: $ => prec(0, seq(
      'import',
      ws($),
      $.string,
      optional(seq(
        ws($),
        ':',
        repeat(seq(ws($), $.ident, ws($), ',')),
        optional(seq(ws($), $.ident)),
      )),
    )),
    include: $ => prec(0, seq(
      'include',
      ws($),
      $.string,
    )),
    for: $ => seq(
      'for',
      ws($),
      field('pattern', $._pattern),
      ws($),
      'in',
      ws($),
      field('value', $._expr),
      ws($),
      choice($.block, $.content),
    ),
    while: $ => seq(
      'while',
      ws($),
      field('test', $._expr),
      ws($),
      choice($.block, $.content),
    ),
    show: $ => seq(
      'show',
      ws($),
      optional(seq(
        field('pattern', $._expr),
        ws($),
      )),
      ':',
      ws($),
      field('value', $._expr),
    ),
    return: $ => seq('return', optional(seq(ws($), $._expr))),
    return_inline: $ => prec(-1, seq('return', optional(seq(ws($), choice($._stmt, $._item))))),
    flow: $ => choice('break', 'continue'),
    auto: $ => 'auto',
    none: $ => 'none',
    builtin: $ => choice(
      'align',
      'assert',
      'black',
      'blue',
      'bottom',
      'box',
      'center',
      'circle',
      'cmyk',
      'emph',
      'eval',
      'gray',
      'green',
      'grid',
      'h',
      'heading',
      'horizon',
      'image',
      'left',
      'link',
      'list',
      'locate',
      'luma',
      'max',
      'metadata',
      'min',
      'navy',
      'page',
      'pagebreak',
      'panic',
      'par',
      'parbreak',
      'purple',
      'query',
      'rect',
      'red',
      'regex',
      'repr',
      'rgb',
      'right',
      'rotate',
      'scale',
      'squate',
      'strong',
      'text',
      'top',
      'type',
      'v',
      'white',
    ),
  },
});

